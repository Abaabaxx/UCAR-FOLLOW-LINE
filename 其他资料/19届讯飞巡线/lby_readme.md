# ROS 巡线机器人工作原理解析

本文档详细解析该 ROS 巡线机器人项目的核心工作流程，主要分为三大模块：**图像处理**、**核心巡线逻辑** 和 **底盘运动控制**。

---

## 一、 图像处理模块

图像处理是整个巡线任务的第一步，其目标是将摄像头输入的原始彩色图像转换为可供后续算法分析的、简洁的二值化图像。

该项目的预处理流程非常直接高效，特点是**没有使用HSV色彩空间转换，也没有进行逆透视变换(IPM)**。

其具体步骤如下：

1.  **订阅图像话题**: 节点启动后，会订阅在 `config/image.cfg` 文件中定义的图像话题（默认为 `/camera/image_raw`），接收来自摄像头的实时画面。

2.  **自定义二值化**: 算法跳过了传统的 `RGB -> 灰度图` 的转换步骤，而是采用了一种更直接的 **“基于BGR通道阈值的二值化”** 方法。
    *   它遍历原始彩色图像的每一个像素。
    *   通过 `getColorNumber` 函数判断像素颜色：如果一个像素点的 **BGR三个颜色通道值均大于** `line_threshold_` (在`config/image.cfg`中配置) 这个阈值，则该像素被认为是 **“线”**，赋值为 `255` (白色)。
    *   所有其他像素则被认为是 **“可通过区域”** 或背景，赋值为 `1`。
    *   经过这个过程，原始的彩色图像被转换成一张只包含 `255` 和 `1` 两种像素值的单通道图像，极大地简化了后续的路径识别任务。

这种方法的优点是计算量极小、速度快，适用于巡线颜色（如白色）与背景颜色对比强烈的场景。

---

## 二、 核心巡线逻辑算法

这是整个项目最核心的部分，在 `processImage` 函数中实现。它的任务是在二值化图像上，找出车辆应该行驶的路径中心线。

该算法采用了一种非常巧妙的 **“由下至上，逐行扫描搜索”** 的策略。

1.  **初始化**: 算法从二值化图像的**最底下一行**开始向上扫描。初始的搜索中心点 `center_x` 被设置为图像的水平中点。

2.  **逐行搜索**:
    *   对于图像中的每一行（从下往上），算法以上一行计算出的 `center_x` 为起点。
    *   从 `center_x` **向左**遍历，找到第一个值为 `255` 的点，记为路径的**左边界 (`leftBoundary`)**。
    *   从 `center_x` **向右**遍历，找到第一个值为 `255` 的点，记为路径的**右边界 (`rightBoundary`)**。
    *   当前行的路径中心点就被确定为左右边界的中点：`new_center_x = (leftBoundary + rightBoundary) / 2`。
    *   这个 `new_center_x` 将作为下一行（更靠上的一行）搜索的起始点。

3.  **特殊情况处理与补线**:
    *   **单边线**: 如果只搜索到左边界或右边界，算法会利用图像的边缘来估算中心点，保证中心线的连续性。
    *   **短暂丢线**: 如果在某一行左右边界都找不到（例如，赛道上的虚线部分或污迹），算法会默认使用图像中心作为当前行的中心点，实现“补线”功能，帮助车辆“盲走”一小段距离。
    *   **终点与转弯**: 当向上扫描时，若发现搜索起始点 `center_x` 本身就压在了线上（像素值为`255`），这被视为一个重要信号。算法会判断为到达了路径尽头（终点）或需要进行大幅度转弯（如T字路口或直角弯）。代码中包含了针对直角弯的特殊处理逻辑，确保顺利过弯。
    *   **停车判断**: 当连续检测到很少的路径点并且触发了终点信号时，`is_stop` 标志位会被设为 `true`。

4.  **可视化发布**: 为了调试和监控，算法会创建一个新的空白彩色图像，将上述步骤计算出的所有中心点连接起来，绘制成一条**黄色的路径中心线**，并发布到 `/img_follow` 话题。我们可以在 Rviz 中订阅此话题，直观地看到算法的实时运行效果。

---

## 三、 底盘运动控制

运动控制模块的目标是根据图像模块计算出的路径中心线，生成具体的电机控制指令，驱动小车平滑地沿线行驶。这部分逻辑主要在 `LineFollower` 类的 `followLine` 函数中。

1.  **计算误差 (Error)**:
    *   控制模块首先分析 `processImage` 函数生成的那张带有黄色中心线的图像。
    *   它会重点关注图像的**下半部分区域**（这部分区域代表离车体最近、最需要优先跟随的路径）。
    *   通过计算该区域内所有黄色像素点的**平均水平坐标 (`avgX`)**，来确定当前的目标路径位置。
    *   **误差 `error`** 被定义为目标路径位置与图像正中心 (`centerX`) 的偏差：`error = avgX - centerX`。
        *   `error > 0`：线在车体右侧，需向右转。
        *   `error < 0`：线在车体左侧，需向左转。
        *   `error ≈ 0`：小车正行驶在路径中心。

2.  **PID 控制器**:
    *   该项目使用了一个功能完备的PID控制器来根据 `error` 计算小车的**转向角速度**。
    *   **P (Proportional - 比例)**: 误差 `error` 的大小直接决定了当前的转向幅度。误差越大，转弯越急。
    *   **I (Integral - 积分)**: 累积历史误差。用于消除静态误差，例如，当车辆持续小幅度偏离中心线时，积分项会逐渐增大，施加一个持续的纠正力，让车体完全回正。
    *   **D (Derivative - 微分)**: 计算误差的变化率。用于预测误差趋势，可以有效抑制车辆在修正方向时的“过冲”现象，使行驶轨迹更平滑、稳定。
    *   **高级特性**:
        *   **自适应增益**: 当误差很大时（如遇到急弯），控制器会自动增大P和D项的系数，使转向响应更迅速；在直道上则恢复正常值。
        *   **积分分离与限幅**: 只有当误差较小时才累积积分项，并对积分项的总量设限，有效防止了积分饱和导致系统失控。
        *   **死区 (Deadzone)**: 忽略极小的误差，防止车辆在直线行驶时因传感器噪声而产生不必要的高频小幅摆动。

3.  **发布速度指令**:
    *   小车的**前进线速度**被设置为一个在 `config/pid.cfg` 文件中配置的固定值 `max_linear_speed_`。
    *   小车的**转向角速度**由PID控制器的输出 `steeringAngle` 决定。
    *   最后，这两个速度值被封装进标准的 `geometry_msgs/Twist` 消息中，发布到 `/cmd_vel` 话题。机器人底盘的驱动节点会订阅此话题，并将其转换为对电机的具体控制指令，从而完成整个闭环巡线控制。
